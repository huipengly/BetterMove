<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.38">
  <POU Name="MAIN" Id="{02169f48-3937-45f7-92da-1b8b2105f78e}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	MC_Power1: MC_Power;
	MC_MoveAbsolute1: MC_MoveAbsolute;
	MC_ExtSetPointGenDisable1: MC_ExtSetPointGenDisable;
	MC_ExtSetPointGenEnable1: MC_ExtSetPointGenEnable;
//	MC_ExtSetPointGenFeed1: MC_ExtSetPointGenFeed;
	MC_Reset1: MC_Reset;
	axis1: AXIS_REF;
	Power1Output:  ST_McOutputs;
	status: INT;
	MoveTime: LREAL := 0;			//两点间移动时间
	PlcCycleTime: LREAL := 0.01;	//PLC循环时间
	EachTime: LREAL := 1;			//距离曲线离散后,时间间隔T
	wait: LREAL;
	MyGivenPosition : ARRAY[0..10] OF LREAL;
	NextPosition: LREAL;			//拆分之后的下一个距离
	step: LREAL;					//单次移动距离
	LastGivenPosition: LREAL;		//上次给定位置
	GivenPositon: LREAL;			//本次给定位置
	CanGivenPositon: BOOL;			//是否可以给定位置,输出给C++
	IsGivenPositon: BOOL;			//是否有给定位置,C++输入判定
//	GivenPositonBuffer : array[0..10] OF LREAL;
	InitPosition: LREAL := 10;		//机械臂初始化位置
	testcount: INT;
	aa: LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[MC_Power1(
	Axis:= axis1,
	Enable_Positive:= TRUE,
	Enable_Negative:= TRUE,
	);
	
MC_MoveAbsolute1(
	Axis:= axis1, 
	);
	
MC_ExtSetPointGenDisable1(
	Axis:= axis1, );
	
MC_ExtSetPointGenEnable1(
	Axis:= axis1,  );

MC_Reset1(
	Axis:= axis1,  );
	
axis1.NcToPlc.ActPos;
	
CASE status OF
	0://init 初始化
		MC_Power1.Enable := FALSE;
		MC_ExtSetPointGenEnable1.Execute := FALSE;
		MC_ExtSetPointGenDisable1.Execute := FALSE;
		MC_MoveAbsolute1.Execute := FALSE;
		MC_Reset1.Execute := FALSE;
	
		//测试用给定数据
		MyGivenPosition[0] := 10;
		MyGivenPosition[1] := 9.5;
		MyGivenPosition[2] := 10;
		MyGivenPosition[3] := 10.5;
		MyGivenPosition[4] := 10.4;
		MyGivenPosition[5] := 10.5;
		MyGivenPosition[6] := 11;
		MyGivenPosition[7] := 11.5;
		MyGivenPosition[8] := 11;
		MyGivenPosition[9] := 10;
		IsGivenPositon := TRUE;
		GivenPositon := MyGivenPosition[0];
		testcount := 1;
		//测试用结束
		
		status := 1;
		wait := 0;
	1://power 使能
		MC_Power1.Enable := TRUE;
		wait := wait + PlcCycleTime;
		IF wait>1 THEN
			status := 2;
		END_IF
	2://move 移动到初始位置
		MC_MoveAbsolute1.Position := InitPosition;
		MC_MoveAbsolute1.Velocity := 2;
		MC_MoveAbsolute1.Execute := TRUE;
		LastGivenPosition := InitPosition;
		IF MC_MoveAbsolute1.Done THEN
			MC_MoveAbsolute1.Execute := FALSE;
			status := 3;
		END_IF
	3://等待变量输入,并计算单次移动距离
		IF IsGivenPositon THEN
			LastGivenPosition := axis1.NcToPlc.ActPos;//记录上次给定位置
			step := (GivenPositon - LastGivenPosition) * PlcCycleTime * EachTime;//将大距离拆分为每次时间循环改变位置
			NextPosition := GivenPositon;
			status := 4;
		END_IF
	4://enable 按照外部给定运动
		MC_ExtSetPointGenEnable1.Execute := TRUE;
		IF MC_ExtSetPointGenEnable1.Enabled THEN
			LastGivenPosition := LastGivenPosition + step;
			MC_ExtSetPointGenFeed(
				Position:= LastGivenPosition,
				Velocity:= 0, 
				Acceleration:= 0, 
				Direction:= 1, 
				Axis:= axis1);
		END_IF
			aa := ABS(LastGivenPosition - NextPosition);
			IF ABS(LastGivenPosition - NextPosition) <= ABS(step) THEN		//已经走到目标位置
				//IF判定想判定等于,但是有问题,则判定两个的差的绝对值小于一次移动的距离.
				//测试用
				IF testcount <= 9 THEN
					IsGivenPositon := TRUE;
					GivenPositon := MyGivenPosition[testcount];
					testcount := testcount + 1;
				ELSE
					IsGivenPositon := FALSE;
				END_IF
				//测试用结束
				IF IsGivenPositon THEN
					step := (GivenPositon - LastGivenPosition) * PlcCycleTime * EachTime;
					LastGivenPosition := NextPosition;//记录上次给定位置
					NextPosition := GivenPositon;
				ELSE
					status := 3;	//返回状态3，等待位置给定
				END_IF
			END_IF
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>